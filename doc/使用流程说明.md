# 使用流程说明

    该框架会在每个分布式节点上使用，节点可以在任何位置，只需保证消息的正常发送和逻辑的交叉运行（不会造成逻辑上的死锁）。

## Root 节点

    整个集群的根节点，所发出的操作可以传递到整个集群（包括子集群中）。

```c++
Cluster root = create_cluster(self_id, communicator, processor);

Cluster::IdentitySet set;

/// 添加所有直系子节点（不包括子节点的子节点）。
...

/// 启动集群
root.start_cluster(set, false);

StatusFlag flag;

/// 创建操作
flag = root.broadcast(rule);
TDCF_CHECK_SUCCESS(flag)

flag = root.scatter(rule);
TDCF_CHECK_SUCCESS(flag)

flag = root.reduce(rule);
TDCF_CHECK_SUCCESS(flag)

flag = root.all_reduce(rule);
TDCF_CHECK_SUCCESS(flag)

flag = root.reduce_scatter(rule);
TDCF_CHECK_SUCCESS(flag)


while (flag == StatusFlag::Success && && 本集群操作未完成) {
    flag = root->handle_a_loop();
}

TDCF_CHECK_SUCCESS(flag)

/// 结束集群
flag = root->end_cluster();
```

## NodeRoot 节点

    拥有父节点，所发出的操作可以传递到自己所在的集群中（包括自己所在的集群的子集群）。

```c++
Cluster node_root = create_cluster(self_id, communicator, processor);

Cluster::IdentitySet set;

/// 添加所有直系子节点（不包括子节点的子节点）。
...

/// 启动集群
node_root.start_cluster(set, true);

StatusFlag flag;

/// 创建操作
flag = node_root.broadcast(rule);
TDCF_CHECK_SUCCESS(flag)

flag = node_root.scatter(rule);
TDCF_CHECK_SUCCESS(flag)

flag = node_root.reduce(rule);
TDCF_CHECK_SUCCESS(flag)

flag = node_root.all_reduce(rule);
TDCF_CHECK_SUCCESS(flag)

flag = node_root.reduce_scatter(rule);
TDCF_CHECK_SUCCESS(flag)

bool root_end = false;
while (flag == StatusFlag::Success && (本集群操作未完成 || !root_end)) {
    flag = node_root->handle_a_loop();
    if (flag == StatusFlag::ClusterOffline) {
        root_end = true;
        flag = StatusFlag::Success;
    }
}

/// 结束集群
flag = node_root->end_cluster();
```

## PureNode 节点

    拥有父节点，不能发出任何操作。

```c++
Node node = create_node(self_id, communicator, processor);

/// 启动节点
node.start_node();

StatusFlag flag = StatusFlag::Success;
while (flag == StatusFlag::Success) {
    flag = node.handle_a_loop();
}

/// 完成父节点的任务后自动关闭。
```